<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KIN Pro Teleprompter - With Recording</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #111827 0%, #1f2937 50%, #111827 100%);
            color: white;
            min-height: 100vh;
        }
        html, body { height: 100%; }

        /* When on the reading screen, lock the page to the viewport and scroll only inside the prompter */
        body.reading-mode {
            height: 100dvh; /* iOS dynamic viewport height */
            overflow: hidden;
        }


        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        h1 {
            text-align: center;
            font-size: 3rem;
            margin-bottom: 1rem;
            background: linear-gradient(135deg, #34d399 0%, #3b82f6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
        }

        .logo {
            text-align: center;
            margin-bottom: 1.5rem;
            display: flex;
            justify-content: center;
        }

        .logo-container {
            position: relative;
        }

        .logo-glow {
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, #10b981 0%, #3b82f6 100%);
            filter: blur(40px);
            opacity: 0.3;
        }

        .logo img {
            position: relative;
            height: 4rem;
        }

        .subtitle {
            text-align: center;
            color: #9ca3af;
            font-size: 1.125rem;
            margin-bottom: 0.5rem;
        }

        .powered-by {
            text-align: center;
            color: #6b7280;
            font-size: 0.875rem;
            margin-bottom: 2rem;
        }

        .setup-screen {
            display: block;
        }

        .reading-screen {
            display: none;
            height: 100dvh;
            min-height: 0;
            flex-direction: column;
        }

        textarea {
            width: 100%;
            height: 400px;
            padding: 1.25rem;
            background: rgba(17, 24, 39, 0.8);
            color: white;
            border: 1px solid #374151;
            border-radius: 0.75rem;
            font-size: 1.125rem;
            line-height: 1.6;
            resize: none;
            transition: all 0.3s;
        }

        textarea:focus {
            outline: none;
            border-color: #10b981;
            box-shadow: 0 0 0 3px rgba(16, 185, 129, 0.1);
        }

        .speed-buttons {
            display: flex;
            gap: 1rem;
            margin: 1.5rem 0;
        }

        .speed-btn {
            flex: 1;
            padding: 0.75rem;
            background: #1f2937;
            color: #d1d5db;
            border: none;
            border-radius: 0.5rem;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            text-transform: capitalize;
        }

        .speed-btn.active {
            background: #3b82f6;
            color: white;
        }

        .speed-btn:hover {
            background: #374151;
        }

        .speed-btn.active:hover {
            background: #2563eb;
        }

        .fine-tune {
            margin: 1.5rem 0;
        }

        .fine-tune label {
            display: block;
            font-size: 0.875rem;
            color: #9ca3af;
            margin-bottom: 0.5rem;
        }

        .fine-tune input {
            width: 100%;
            padding: 0.75rem;
            background: #1f2937;
            color: white;
            border: 1px solid #374151;
            border-radius: 0.5rem;
        }

        .fine-tune input:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .start-btn {
            width: 100%;
            padding: 1.5rem;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            border-radius: 0.75rem;
            font-size: 1.5rem;
            font-weight: 700;
            cursor: pointer;
            margin-top: 1.5rem;
            transition: all 0.3s;
            box-shadow: 0 10px 25px rgba(16, 185, 129, 0.2);
        }

        .start-btn:hover {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            transform: scale(1.02);
        }

        .start-btn:disabled {
            background: #374151;
            cursor: not-allowed;
            box-shadow: none;
            transform: scale(1);
        }

        .footer {
            margin-top: 3rem;
            text-align: center;
            color: #6b7280;
            font-size: 0.875rem;
            padding: 2rem 0;
        }

        .footer-links {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            margin-top: 1rem;
            font-size: 0.75rem;
        }

        .footer-links a {
            color: #6b7280;
            text-decoration: none;
            transition: color 0.3s;
        }

        .footer-links a:hover {
            color: #10b981;
        }

        .controls {
            background: #1f2937;
            padding: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 1rem;
            border-bottom: 1px solid #374151;
            flex-wrap: wrap;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .control-btn {
            padding: 0.75rem;
            background: #3b82f6;
            color: white;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .control-btn:hover {
            background: #2563eb;
        }

        .control-btn:disabled {
            background: #374151;
            cursor: not-allowed;
        }

        .record-btn {
            background: #dc2626;
        }

        .record-btn:hover {
            background: #b91c1c;
        }

        .record-btn.recording {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .download-btn {
            background: #10b981;
        }

        .download-btn:hover {
            background: #059669;
        }

        .reset-btn {
            background: #4b5563;
        }

        .reset-btn:hover {
            background: #374151;
        }

        .content-area {
            display: flex;
            flex: 1;
            overflow: hidden;
        min-height: 0;
        }

        .prompter {
            flex: 1;
            overflow-y: auto;
            background: black;
            padding: 2rem;
            scroll-behavior: smooth;
        }
        
        .prompter-content {
            max-width: 700px;
            margin: 0 auto;
            padding: 2rem 0;
        }
        
        .line {
            margin: 2rem 0;
            padding: 1.5rem 2rem;
            border-radius: 0.5rem;
            transition: all 0.7s;
            line-height: 1.6;
        }

        .line.current {
            /* FONT SIZE CONTROL: Use CSS variable */
            font-size: var(--current-font-size);
            font-weight: 700;
            color: white;
            opacity: 1;
            background: rgba(31, 41, 55, 0.5);
            border-left: 4px solid #3b82f6;
        }

        .line.past {
            font-size: 1.5rem;
            color: #4b5563;
            opacity: 0.3;
        }

        .line.future {
            font-size: 1.5rem;
            color: #374151;
            opacity: 0.2;
        }

        .camera-panel {
            width: 320px;
            background: #1f2937;
            padding: 1rem;
            display: flex;
            flex-direction: column;
        }

        .camera-panel h3 {
            margin-bottom: 1rem;
        }

        video {
            width: 100%;
            aspect-ratio: 16/9;
            background: black;
            border-radius: 0.5rem;
        }

        .info {
            font-size: 0.875rem;
            color: #9ca3af;
            margin-top: 1rem;
        }

        .segment-count {
            font-size: 0.875rem;
            color: #9ca3af;
        }

        .speed-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .speed-input {
            width: 6rem;
            padding: 0.5rem;
            background: #374151;
            color: white;
            border: 1px solid #4b5563;
            border-radius: 0.5rem;
            font-size: 0.875rem;
        }
    
        .toggle-btn {
            background: #4b5563;
        }
        .toggle-btn:hover {
            background: #374151;
        }
        .toggle-btn.active {
            background: #10b981;
        }
        .toggle-btn.active:hover {
            background: #059669;
        }

        .overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.75);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 1.5rem;
        }

        .overlay-card {
            width: 100%;
            max-width: 520px;
            background: #111827;
            border: 1px solid #374151;
            border-radius: 1rem;
            padding: 1.5rem;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            text-align: center;
        }

        .overlay-card h2 {
            font-size: 1.75rem;
            margin-bottom: 0.75rem;
            background: linear-gradient(135deg, #34d399 0%, #3b82f6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 800;
        }

        .overlay-card p {
            color: #d1d5db;
            line-height: 1.6;
            margin-bottom: 1rem;
        }

        .overlay-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
            flex-wrap: wrap;
        }
            
        .input-select {
            padding: 0.6rem 0.75rem;
            background: #374151;
            color: white;
            border: 1px solid #4b5563;
            border-radius: 0.5rem;
            font-size: 0.875rem;
        }

        .badge {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            padding: 0.25rem 0.6rem;
            border-radius: 999px;
            font-size: 0.75rem;
            font-weight: 700;
            border: 1px solid #374151;
            background: rgba(31, 41, 55, 0.7);
            color: #d1d5db;
        }

        .badge.off {
            border-color: rgba(220, 38, 38, 0.6);
            color: #fecaca;
        }

        .badge.on {
            border-color: rgba(16, 185, 129, 0.6);
            color: #bbf7d0;
        }

        .camera-off-notice {
            margin-top: 0.75rem;
            padding: 0.75rem;
            border-radius: 0.5rem;
            border: 1px dashed #4b5563;
            color: #d1d5db;
            background: rgba(17, 24, 39, 0.5);
            font-size: 0.875rem;
        }

        .countdown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.8);
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .countdown-number {
            font-size: 15rem;
            font-weight: 900;
            color: #10b981;
            text-shadow: 0 0 40px rgba(16, 185, 129, 0.8);
            animation: countdownPulse 1s ease-in-out;
        }

        @keyframes countdownPulse {
            0% { transform: scale(0.5); opacity: 0; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }

        /* NEW CSS for Notification Toast */
        .notification-toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #f87171; /* Default error color */
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            z-index: 2000;
            opacity: 0;
            transition: opacity 0.3s, bottom 0.3s;
            font-size: 1rem;
            max-width: 90%;
            text-align: center;
        }

        .notification-toast.error {
            background-color: #dc2626; /* Red for errors */
        }

        .notification-toast.success {
            background-color: #10b981; /* Green for success (optional, but good practice) */
        }
        /* END NEW CSS */

        /* =======================================================
           MOBILE RESPONSIVENESS FIX (Centering and Stacking)
           ======================================================= */
        @media (max-width: 768px) {
            /* --- General Layout Adjustments --- */
            .container {
                padding: 1rem;
            }
            
            h1 {
                font-size: 2rem;
            }

            .subtitle {
                font-size: 1rem;
            }
            
            /* --- Reading Screen (Full Height & Vertical Stack) --- */
            .reading-screen {
                height: auto;
                min-height: 100vh;
                padding-bottom: 5rem; /* Space for the bottom controls */
            }
            
            .content-area {
                /* Main reading area must stack vertically */
                flex-direction: column;
                height: auto;
                overflow: hidden;
                flex: 1;
                min-height: 0;
                }

            /* --- Camera Panel (Top 100% Width) --- */
            .camera-panel {
                width: 100%;
                padding: 0.5rem;
                order: 1; /* Puts camera on top */
                /* Ensure the camera preview is centered */
                display: flex;
                justify-content: center;
                align-items: flex-start;
            }

            video {
                max-width: 100%;
                height: auto;
            }

            /* --- Prompter (The Centering Solution) --- */
            .prompter {
                width: 100%;
                padding: 0 0.5rem; /* Minimal side padding */
                order: 2; 
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                flex: 1;
                min-height: 0;
                
                /* 1. Make the prompter a flexible container itself */
                display: flex;
                /* 2. Vertically arrange its internal elements (like the content block) */
                flex-direction: column;
                /* 3. CENTER its internal elements (the prompter-content div) horizontally */
                align-items: center; 
            }

            .prompter-content {
                /* 1. Allows the content to fill the width it needs but not more than 100% */
                max-width: 100%;
                padding: 1rem 0;
                
                /* 2. CENTER THE TEXT inside the block */
                text-align: center; 
            }

            /* 3. Explicitly center the line elements (the divs inside prompterContent) */
            #prompterContent > div {
                margin: 0 auto;
            }

            /* --- Controls Bar & Buttons --- */
            .controls {
                flex-wrap: wrap;
                gap: 0.5rem;
                padding: 0.75rem 0.5rem;
                justify-content: space-between; /* Restore justify-content */
            }

            .control-btn, 
            .speed-buttons button, 
            .input-select {
                flex-grow: 1;
                font-size: 0.8rem;
                padding: 0.5rem;
            }

            /* Restore button specific width fixes */
            #cameraSelectReading, 
            #micSelectReading {
                min-width: unset;
                width: auto;
            }
            
            .speed-control {
                flex-grow: 1;
                justify-content: center;
            }

            .speed-input {
                width: 4rem; /* Smaller input for speed */
            }

            .segment-count,
            .info {
                width: 100%;
                text-align: center;
                margin-top: 0.5rem;
                font-size: 0.75rem;
            }
            
            /* Make the font size control less spread out */
            .controls > div:last-of-type { /* Targeting the font size container */
                margin-top: 0.5rem;
            }
        }
    
/* --- Mobile scrolling fixes (iOS/Chrome emulation) --- */
@media (max-width: 900px) {
  /* Make the reading screen a fixed-height flex column */
  #readingScreen, .reading-screen {
    height: 100dvh;
    max-height: 100dvh;
    overflow: hidden;
  }

  /* This is the main scroll container on mobile (NOT the body) */
  .content-area {
    flex: 1 1 auto !important;
    min-height: 0 !important;
    overflow-y: auto !important;
    -webkit-overflow-scrolling: touch;
    overscroll-behavior: contain;
    touch-action: pan-y;
  }

  /* Keep prompter scrollable, but don't trap the entire page */
  .prompter {
    flex: 1 1 auto !important;
    min-height: 40vh;            /* ensures it remains usable */
    max-height: 60vh;            /* prevents endless growth */
    overflow-y: auto !important;
    -webkit-overflow-scrolling: touch;
    overscroll-behavior: contain;
    touch-action: pan-y;
  }

  /* Prevent the camera panel from becoming too tall */
  .camera-panel, .camera-preview, .video-panel {
    max-height: 55vh;
  }

  video#videoPreview {
    max-height: 40vh;
  }
}

</style>
</head>
<body>
    <div class="setup-screen" id="setupScreen">
        <div class="container">
            <div class="logo">
                <div class="logo-container">
                    <div class="logo-glow"></div>
                    <img src="https://cdn.prod.website-files.com/64c7f774c3d8ed1447eec09b/6598dbcd2473ac6bf1c40227_Untitled%20design%20(20).png" alt="KIN Creative" style="position: relative; height: 80px; width: 80px;">
                </div>
            </div>
            <h1>KIN Pro Teleprompter</h1>
            <p class="subtitle">Record like a professional with smooth, centered scrolling</p>
            <p class="powered-by">Powered by KIN Creative</p>
            
            <div>
                <label style="display: block; font-size: 1.125rem; margin-bottom: 0.5rem;">Paste Your Content</label>
                <textarea id="contentInput" placeholder="Paste your blog post content here..." style="height: 12rem;"></textarea>
                <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 0.5rem;">
                  <p class="segment-count" id="segmentCount">Content will be split into segments</p>
                  <div id="timeEstimate" class="estimate-badge" style="display:none;">Est: 00:00</div>
                  <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.875rem; color: #9ca3af; cursor: pointer;">
                      <input type="checkbox" id="commaToggle" style="width: 1rem; height: 1rem; cursor: pointer;"> Split at commas too
                  </label>
              </div>
            </div>

            <div id="previewContainer" style="display: none;">
                <div style="display:flex; justify-content:space-between; align-items:center; gap:0.75rem; margin-bottom:0.5rem;"><label style="display: block; font-size: 1.125rem;">Preview (how it will appear)</label><span id="cameraStatusBadge" class="badge off">üì∑ Camera: OFF</span></div>
                <div id="parsedPreview" style="width: 100%; height: 12rem; padding: 1rem; background: rgba(31, 41, 55, 0.5); color: #d1d5db; border-radius: 0.5rem; border: 1px solid #374151; overflow-y: auto; white-space: pre-wrap; line-height: 1.6;"></div>
            </div>

            <div>
                <label style="display: block; font-size: 1.125rem; margin: 1.5rem 0 0.75rem;">Scroll Speed</label>
                <div class="speed-buttons">
                    <button class="speed-btn" data-speed="slow">Slow</button>
                    <button class="speed-btn active" data-speed="medium">Medium</button>
                    <button class="speed-btn" data-speed="fast">Fast</button>
                </div>
                <div class="fine-tune">
                    <label>Fine-tune speed (milliseconds per segment)</label>
                    <input type="number" id="customSpeed" min="500" max="10000" step="100" value="3500">
                    <p style="font-size: 0.75rem; color: #6b7280; margin-top: 0.25rem;">Lower = faster (500-10000ms)</p>
                </div>
            </div>

            
            <div style="margin-top: 1.5rem;">
                <label style="display:block; font-size: 1rem; margin-bottom: 0.5rem;">Camera mode</label>
                <select id="cameraMode" style="width:100%; padding:0.75rem; background:#1f2937; color:white; border:1px solid #374151; border-radius:0.5rem;">
                    <option value="off">Teleprompter only (no camera)</option>
                    <option value="on">Enable camera (for recording)</option>
                </select>
            </div>

            <div id="inputSelectContainer" style="display:none; margin-top: 1rem;">
                <label style="display:block; font-size: 0.875rem; color:#9ca3af; margin-bottom:0.25rem;">Camera source</label>
                <select id="cameraSelect" style="width:100%; padding:0.75rem; background:#1f2937; color:white; border:1px solid #374151; border-radius:0.5rem;">
                    <option value="">Default camera</option>
                </select>

                <label style="display:block; font-size: 0.875rem; color:#9ca3af; margin:0.75rem 0 0.25rem;">Microphone source</label>
                <select id="micSelect" style="width:100%; padding:0.75rem; background:#1f2937; color:white; border:1px solid #374151; border-radius:0.5rem;">
                    <option value="">Default microphone</option>
                </select>
                <p style="font-size: 0.75rem; color:#6b7280; margin-top:0.5rem;">Device names appear after you allow access once.</p>
            </div>

            <button class="start-btn" id="startBtn">‚èµ Start Teleprompter</button>

            <div class="footer">
                <p>¬© 2025 KIN Creative - Family Above All</p>
                <div class="footer-links">
                    <a href="https://www.kincreative.io" target="_blank">Visit KIN Creative</a>
                    <span>‚Ä¢</span>
                    <a href="https://www.kincreative.io/privacy-policy" target="_blank">Privacy Policy</a>
                </div>
            </div>
        </div>
    </div>

    <div class="reading-screen" id="readingScreen">
        <div class="controls">
            <button class="control-btn" id="pauseBtn">‚è∏ Pause</button>
            <button class="control-btn" id="prevBtn">‚è´ Previous</button>
            <button class="control-btn" id="nextBtn">‚è¨ Next</button>
            <button class="control-btn" id="enableCameraBtn" style="background:#10b981;">üì∑ Enable Camera</button>
            <button class="record-btn control-btn" id="recordBtn">‚è∫ Record</button>
            <button class="download-btn control-btn" id="downloadBtn" style="display: none;">‚¨á Download</button>
            <button class="reset-btn control-btn" id="resetBtn">‚Üª Reset</button>
            
            <div class="speed-buttons">
                <button class="speed-btn" data-speed="slow">Slow</button>
                <button class="speed-btn active" data-speed="medium">Medium</button>
                <button class="speed-btn" data-speed="fast">Fast</button>
            </div>
            
            <div class="speed-control">
                <input type="number" class="speed-input" id="speedInput" min="500" max="10000" step="100" value="3500">
                <span style="font-size: 0.75rem; color: #9ca3af;">ms</span>
            </div>
            
            
<button class="control-btn toggle-btn" id="mirrorBtn">ü™û Mirror</button>
<button class="control-btn toggle-btn" id="flipBtn">‚Üï Vertical Flip</button>

<div style="display:flex; align-items:center; gap:0.5rem;">
    <span style="color:#9ca3af; font-size:0.875rem;">A</span>
    <input type="range" id="fontSizeRange" min="2" max="6" step="0.1" value="3.5" style="width: 80px;">
    <span style="color:#9ca3af; font-size:1.5rem;">A</span>
</div>

<select id="cameraSelectReading" class="input-select" style="display:none; min-width: 10rem;"><option value="">Camera: Default</option></select>
<select id="micSelectReading" class="input-select" style="display:none; min-width: 10rem;"><option value="">Mic: Default</option></select>

<span class="segment-count" id="positionIndicator">Segment 1 of 1</span>
        </div>

        <div class="content-area">
            <div class="prompter" id="prompter">
                <div class="countdown-overlay" id="countdownOverlay">
                    <span class="countdown-number" id="countdownNumber"></span>
                </div>
                <div class="prompter-content" id="prompterContent"></div>
            </div>
            
            <div class="camera-panel">
                <h3>Camera Preview</h3>
                <video id="videoPreview" autoplay muted playsinline></video>
                <div class="camera-off-notice" id="cameraOffNotice" style="display:none;">Camera is OFF. Click <b>Enable Camera</b> to preview & record.</div>
                <div class="info">
                    <p>‚Ä¢ Click Record to start capturing</p>
                    <p>‚Ä¢ Recording timer shows duration</p>
                    <p>‚Ä¢ Download when finished</p>
                    <p style="font-size: 0.75rem; color: #6b7280; margin-top: 0.75rem;">Video saves as .webm format</p>
                </div>
            </div>
        </div>
    </div>

<div class="overlay" id="completeOverlay" role="dialog" aria-modal="true" aria-labelledby="completeTitle">
    <div class="overlay-card">
        <h2 id="completeTitle">Recording complete</h2>
        <p>You‚Äôve reached the end of your script. Your recording has been stopped automatically (if it was running). You can download it now, or reset to record again.</p>
        <div class="overlay-actions">
            <button class="download-btn control-btn" id="overlayDownloadBtn" style="display: none;">‚¨á Download</button>
            <button class="control-btn" id="overlayCloseBtn">Continue</button>
            <button class="reset-btn control-btn" id="overlayResetBtn">‚Üª Reset</button>
        </div>
    </div>
</div>

<div class="notification-toast" id="notificationToast"></div>
<script>
/* =========================
   KIN Pro Teleprompter
   Enhancements:
   - Start without camera
   - Enable camera button on reading screen
   - Camera + microphone selectors (setup + reading)
   - Camera OFF badge in preview panel
   - Content Parsing Fix
   - Countdown Timer
   - Font Size Control (re-added)
   - Smooth Error Notification (NEW)
   - Estimated Time Feature (RESTORED)
   - Mobile Responsiveness (FIXED)
   - Scrolling Off-Screen Fix (NEW)
   ========================= */

let lines = [];
let currentLine = 0;
let isScrolling = false;
let scrollInterval = null;
let currentSpeed = 3500;
let speedPreset = 'medium';
let splitAtCommas = false;
let currentFontSize = 3.5; // Initial font size in rem

let mediaRecorder = null;
let recordedChunks = [];
let stream = null;
let isRecording = false;
let recordingTimer = null;
let recordingTime = 0;

let isMirrored = false;
let isFlipped = false;

let cameraEnabled = false;
let selectedCameraId = null;
let selectedMicId = null;

const speedPresets = { slow: 3000, medium: 3500, fast: 1500 };

// Setup screen elements
const contentInput = document.getElementById('contentInput');
const segmentCount = document.getElementById('segmentCount');
const parsedPreview = document.getElementById('parsedPreview');
const previewContainer = document.getElementById('previewContainer');
const commaToggle = document.getElementById('commaToggle');
const customSpeedInput = document.getElementById('customSpeed');
const startBtn = document.getElementById('startBtn');
const setupScreen = document.getElementById('setupScreen');
const readingScreen = document.getElementById('readingScreen');
// ADDED: Element for the time estimate
const timeEstimate = document.getElementById('timeEstimate');

// New setup inputs
const cameraModeSelect = document.getElementById('cameraMode');
const inputSelectContainer = document.getElementById('inputSelectContainer');
const cameraSelect = document.getElementById('cameraSelect');
const micSelect = document.getElementById('micSelect');
const cameraStatusBadge = document.getElementById('cameraStatusBadge');

// Reading screen elements
const pauseBtn = document.getElementById('pauseBtn');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');
const enableCameraBtn = document.getElementById('enableCameraBtn');
const recordBtn = document.getElementById('recordBtn');
const downloadBtn = document.getElementById('downloadBtn');
const resetBtn = document.getElementById('resetBtn');
const speedInput = document.getElementById('speedInput');
const positionIndicator = document.getElementById('positionIndicator');
const prompterContent = document.getElementById('prompterContent');
const videoPreview = document.getElementById('videoPreview');
const prompter = document.getElementById('prompter');
const cameraOffNotice = document.getElementById('cameraOffNotice');

// Reading selectors
const cameraSelectReading = document.getElementById('cameraSelectReading');
const micSelectReading = document.getElementById('micSelectReading');
const fontSizeRange = document.getElementById('fontSizeRange');

// Mirror/Flip + overlay elements
const mirrorBtn = document.getElementById('mirrorBtn');
const flipBtn = document.getElementById('flipBtn');

const completeOverlay = document.getElementById('completeOverlay');
const overlayCloseBtn = document.getElementById('overlayCloseBtn');
const overlayResetBtn = document.getElementById('overlayResetBtn');
const overlayDownloadBtn = document.getElementById('overlayDownloadBtn');

// Countdown elements
const countdownOverlay = document.getElementById('countdownOverlay');
const countdownNumber = document.getElementById('countdownNumber');

// NEW: Notification Toast element
const notificationToast = document.getElementById('notificationToast');

/* ---------- Helpers ---------- */
function setBadge(on) {
  if (!cameraStatusBadge) return;
  cameraStatusBadge.classList.toggle('on', on);
  cameraStatusBadge.classList.toggle('off', !on);
  cameraStatusBadge.textContent = on ? 'üì∑ Camera: ON' : 'üì∑ Camera: OFF';
}

function updateCameraUI() {
  setBadge(cameraEnabled);

  if (enableCameraBtn) enableCameraBtn.style.display = cameraEnabled ? 'none' : 'inline-flex';
  if (cameraOffNotice) cameraOffNotice.style.display = cameraEnabled ? 'none' : 'block';
  if (recordBtn) recordBtn.disabled = !cameraEnabled || !stream;

  const showSelectors = cameraEnabled;
  if (cameraSelectReading) cameraSelectReading.style.display = showSelectors ? 'inline-flex' : 'none';
  if (micSelectReading) micSelectReading.style.display = showSelectors ? 'inline-flex' : 'none';
}

function updateFontSize() {
    currentFontSize = parseFloat(fontSizeRange.value);
    prompterContent.style.setProperty('--current-font-size', `${currentFontSize}rem`);
}
if (fontSizeRange) {
    fontSizeRange.addEventListener('input', updateFontSize);
    updateFontSize();
}

/* ---------- Notification Toast (NEW) ---------- */
function showNotification(message, isError = true, duration = 4000) {
    notificationToast.textContent = message;
    notificationToast.classList.remove('error', 'success');
    notificationToast.classList.add(isError ? 'error' : 'success');
    notificationToast.style.bottom = '20px';
    notificationToast.style.opacity = 1;

    setTimeout(() => {
        notificationToast.style.opacity = 0;
        notificationToast.style.bottom = '0px';
    }, duration);
}

/* ---------- Estimated Time Calculation (RESTORED) ---------- */
function updateTimeEstimate(lines) {
    const totalSegments = lines.length;
    const totalTimeMs = totalSegments * currentSpeed;
    const totalSeconds = Math.round(totalTimeMs / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    // Format to MM:SS
    const formattedTime = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    
    timeEstimate.textContent = `Est: ${formattedTime}`;
    // Show the badge only if there is content
    timeEstimate.style.display = totalSegments > 0 ? 'inline-flex' : 'none';
}

// CORRECTED parseContent function
function parseContent(content) {
    // List of common abbreviations to prevent splitting (must be lowercase and include the period)
    const ABBREVIATIONS_SET = new Set([
        'mr.', 'mrs.', 'ms.', 'dr.', 'jr.', 'sr.', 'prof.', 'capt.', 'lt.', 'col.', 'gen.',
        'st.', 'ave.', 'rd.', 'blvd.', 'inc.', 'co.', 'corp.', 'ltd.', 'etc.', 'i.e.', 'e.g.',
        'jan.', 'feb.', 'mar.', 'apr.', 'jun.', 'jul.', 'aug.', 'sep.', 'oct.', 'nov.', 'dec.'
    ]);
    
    // First, normalize all punctuation to have a space after them for consistent splitting detection
    let text = content.replace(/([.?!,])(?=\S)/g, "$1 ");

    // Define the separators based on the toggle setting, capturing the punctuation
    let separators = splitAtCommas ? /([.?!,])\s+/g : /([.?!])\s+/g;
    
    // Split the content by the defined separators, keeping the punctuation mark in the result array
    let potentialSegments = text.split(separators);

    let finalLines = [];
    let currentSegment = "";

    for (let segment of potentialSegments) {
        if (!segment || segment.trim().length === 0) continue;

        let trimmedSegment = segment.trim();

        // FIX: Explicitly ignore segments that are only punctuation marks
        if (trimmedSegment.length === 1 && trimmedSegment.match(/[.?!,]/)) continue;
        
        // Check if the segment ends in a known abbreviation
        let lastWordMatch = trimmedSegment.toLowerCase().match(/(\w+\.)$/);
        let isAbbreviation = lastWordMatch && ABBREVIATIONS_SET.has(lastWordMatch[1]);
        
        if (isAbbreviation) {
            // It's an abbreviation, merge it with the current segment accumulator.
            currentSegment += (currentSegment.length > 0 ? " " : "") + trimmedSegment;
        } else {
            // It's a real segment end. Add accumulated text + current segment to the final list.
            if (currentSegment.length > 0) {
                // If there's accumulated text, append the current segment to it
                finalLines.push(currentSegment + (trimmedSegment.length > 0 ? " " + trimmedSegment : ""));
                currentSegment = "";
            } else {
                // Otherwise, the current segment is a standalone sentence
                finalLines.push(trimmedSegment);
            }
        }
    }
    
    // Push any leftover accumulated text
    if (currentSegment.length > 0) {
        finalLines.push(currentSegment);
    }
    
    // Final cleanup: ensure segments end in punctuation if missing (the original failsafe)
    return finalLines.map(s => {
        let trimmed = s.trim();
        // Check if it ends with one of the allowed punctuations
        if (trimmed.length > 0 && !trimmed.match(/[.?!,]$/)) {
            return trimmed + '.';
        }
        return trimmed;
    }).filter(s => s.length > 0);
}


function applyVideoTransform() {
  const transforms = [];
  if (isMirrored) transforms.push('scaleX(-1)');
  if (isFlipped) transforms.push('scaleY(-1)');
  videoPreview.style.transform = transforms.length ? transforms.join(' ') : 'none';
}

function showCompletionOverlay() {
  overlayDownloadBtn.style.display = (downloadBtn.style.display === 'none') ? 'none' : 'flex';
  completeOverlay.style.display = 'flex';
}

function hideCompletionOverlay() {
  completeOverlay.style.display = 'none';
}

/* ---------- Preview updates ---------- */
function updatePreview() {
  const content = contentInput.value;
  // **FIXED: Lines array is now populated**
  lines = parseContent(content); 

if (lines.length > 0) {
    segmentCount.textContent = `${lines.length} segments detected`;
    startBtn.disabled = false;
    previewContainer.style.display = 'block';
    parsedPreview.textContent = lines.join('\n\n');
    
    // Call the time estimate function
    updateTimeEstimate(lines);
} else {
    segmentCount.textContent = 'Content will be split into segments';
    startBtn.disabled = true;
    previewContainer.style.display = 'none';
    
    // Call the time estimate function to hide the badge
    updateTimeEstimate([]); 
}
}
contentInput.addEventListener('input', updatePreview);
commaToggle.addEventListener('change', () => { splitAtCommas = commaToggle.checked; updatePreview(); });

/* ---------- Speed presets ---------- */
document.querySelectorAll('#setupScreen .speed-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('#setupScreen .speed-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    speedPreset = btn.dataset.speed;
    currentSpeed = speedPresets[speedPreset];
    customSpeedInput.value = currentSpeed;
    updatePreview(); // Ensure estimate updates when speed preset is changed
  });
});

document.querySelectorAll('#readingScreen .speed-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('#readingScreen .speed-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    speedPreset = btn.dataset.speed;
    currentSpeed = speedPresets[speedPreset];
    speedInput.value = currentSpeed;
    restartScrolling();
  });
});

customSpeedInput.addEventListener('input', () => {
    const v = parseInt(customSpeedInput.value);
    if (v >= 500 && v <= 10000) {
        currentSpeed = v;
        updatePreview(); // Recalculate estimate on custom speed change
    }
});

speedInput.addEventListener('input', () => {
  const v = parseInt(speedInput.value);
  if (v >= 500 && v <= 10000) { currentSpeed = v; restartScrolling(); }
});

/* ---------- Mirror/Flip ---------- */
mirrorBtn.addEventListener('click', () => { isMirrored = !isMirrored; mirrorBtn.classList.toggle('active', isMirrored); applyVideoTransform(); });
flipBtn.addEventListener('click', () => { isFlipped = !isFlipped; flipBtn.classList.toggle('active', isFlipped); applyVideoTransform(); });

/* ---------- Overlay ---------- */
overlayCloseBtn.addEventListener('click', hideCompletionOverlay);
overlayResetBtn.addEventListener('click', () => { hideCompletionOverlay(); resetBtn.click(); });
overlayDownloadBtn.addEventListener('click', () => downloadBtn.click());

/* ---------- Device enumeration ---------- */
async function ensureDeviceLabels() {
  try {
    const temp = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
    temp.getTracks().forEach(t => t.stop());
  } catch (e) { /* ignore */ }
}

async function populateDeviceLists() {
  const devices = await navigator.mediaDevices.enumerateDevices();
  const cams = devices.filter(d => d.kind === 'videoinput');
  const mics = devices.filter(d => d.kind === 'audioinput');

  cameraSelect.innerHTML = '<option value="">Default camera</option>';
  cams.forEach((d, idx) => {
    const opt = document.createElement('option');
    opt.value = d.deviceId;
    opt.textContent = d.label || `Camera ${idx + 1}`;
    cameraSelect.appendChild(opt);
  });

  micSelect.innerHTML = '<option value="">Default microphone</option>';
  mics.forEach((d, idx) => {
    const opt = document.createElement('option');
    opt.value = d.deviceId;
    opt.textContent = d.label || `Microphone ${idx + 1}`;
    micSelect.appendChild(opt);
  });

  cameraSelectReading.innerHTML = '<option value="">Camera: Default</option>';
  cams.forEach((d, idx) => {
    const opt = document.createElement('option');
    opt.value = d.deviceId;
    opt.textContent = d.label || `Camera ${idx + 1}`;
    cameraSelectReading.appendChild(opt);
  });

  micSelectReading.innerHTML = '<option value="">Mic: Default</option>';
  mics.forEach((d, idx) => {
    const opt = document.createElement('option');
    opt.value = d.deviceId;
    opt.textContent = d.label || `Microphone ${idx + 1}`;
    micSelectReading.appendChild(opt);
  });

  if (selectedCameraId) { cameraSelect.value = selectedCameraId; cameraSelectReading.value = selectedCameraId; }
  if (selectedMicId) { micSelect.value = selectedMicId; micSelectReading.value = selectedMicId; }
}

cameraModeSelect.addEventListener('change', async () => {
  cameraEnabled = cameraModeSelect.value === 'on';
  inputSelectContainer.style.display = cameraEnabled ? 'block' : 'none';
  setBadge(cameraEnabled);
  if (cameraEnabled) {
    await ensureDeviceLabels();
    await populateDeviceLists();
  }
});

cameraSelect.addEventListener('change', async () => {
  selectedCameraId = cameraSelect.value || null;
  cameraSelectReading.value = cameraSelect.value || '';
  if (stream) await restartMediaStream();
});

micSelect.addEventListener('change', async () => {
  selectedMicId = micSelect.value || null;
  micSelectReading.value = micSelect.value || '';
  if (stream) await restartMediaStream();
});

cameraSelectReading.addEventListener('change', async () => {
  selectedCameraId = cameraSelectReading.value || null;
  cameraSelect.value = cameraSelectReading.value || '';
  if (stream) await restartMediaStream();
});

micSelectReading.addEventListener('change', async () => {
  selectedMicId = micSelectReading.value || null;
  micSelect.value = micSelectReading.value || '';
  if (stream) await restartMediaStream();
});

/* ---------- Media stream ---------- */
async function startMediaStream() {
  if (!cameraEnabled) return;
  try {
    const constraints = {
      video: selectedCameraId ? { deviceId: { exact: selectedCameraId } } : true,
      audio: selectedMicId ? { deviceId: { exact: selectedMicId } } : true
    };
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    videoPreview.srcObject = stream;
    applyVideoTransform();
    updateCameraUI();
  } catch (error) {
    // REPLACED ALERT WITH NOTIFICATION
    showNotification('Error accessing camera/microphone. Please ensure you have given permission and selected a valid device. Error: ' + error.name, true);
    cameraEnabled = false;
    cameraModeSelect.value = 'off';
    inputSelectContainer.style.display = 'none';
    setBadge(false);
    updateCameraUI();
  }
}

function stopMediaStream() {
  if (stream) {
    stream.getTracks().forEach(t => t.stop());
    stream = null;
  }
}

async function restartMediaStream() {
  if (isRecording) stopRecording();
  stopMediaStream();
  await startMediaStream();
}

/* ---------- Enable camera on reading screen ---------- */
enableCameraBtn.addEventListener('click', async () => {
  cameraEnabled = true;
  cameraModeSelect.value = 'on';
  inputSelectContainer.style.display = 'block';
  await ensureDeviceLabels();
  await populateDeviceLists();
  await startMediaStream();
});

/* ---------- Start Teleprompter ---------- */
startBtn.addEventListener('click', async () => {
  lines = parseContent(contentInput.value);
  if (lines.length === 0) return;

  speedInput.value = customSpeedInput.value;
  currentSpeed = parseInt(speedInput.value) || currentSpeed;

  cameraEnabled = (cameraModeSelect.value === 'on');
  setBadge(cameraEnabled);

  setupScreen.style.display = 'none';
  readingScreen.style.display = 'flex';
  document.body.classList.add('reading-mode');
  document.body.classList.add('reading-mode');

  document.querySelectorAll('#readingScreen .speed-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.speed === speedPreset);
  });
  
  updateFontSize();

  currentLine = 0;
  renderContent();

  isScrolling = false;
  pauseBtn.textContent = '‚ñ∂ Start';

  if (cameraEnabled) {
    await ensureDeviceLabels();
    await populateDeviceLists();
    await startMediaStream();
  } else {
    stopMediaStream();
    updateCameraUI();
  }
});

/* ---------- Teleprompter ---------- */
function renderContent() {
  // Use 50vh top/bottom padding to ensure content can scroll to the center
  const topPadding = '<div style="height: 50vh;"></div>';
  const bottomPadding = '<div style="height: 50vh;"></div>';
  prompterContent.innerHTML = topPadding + lines.map((line, index) =>
    `<div class="line ${index === 0 ? 'current' : 'future'}" data-index="${index}">${line.trim()}</div>`
  ).join('') + bottomPadding;
  updatePosition();
  scrollToCenter();
}

function scrollToCenter() {
  const active = prompter.querySelector(`[data-index="${currentLine}"]`);
  
  // NEW FIX: Only attempt to scroll if the 'currentLine' is a valid index.
  if (!active || currentLine >= lines.length) return; 

  const cRect = prompter.getBoundingClientRect();
  const eRect = active.getBoundingClientRect();
  // Calculate the scroll offset to move the current line to the center of the prompter view
  const scrollOffset = (eRect.top - cRect.top) - (cRect.height / 2) + (eRect.height / 2);
  prompter.scrollBy({ top: scrollOffset, behavior: 'smooth' });
}

/* ---------- Countdown Timer ---------- */
function startCountdown() {
    let count = 3;
    countdownOverlay.style.opacity = 1;
    countdownNumber.textContent = count;

    const timer = setInterval(() => {
        count--;
        if (count > 0) {
            countdownNumber.textContent = count;
            countdownNumber.style.animation = 'none';
            void countdownNumber.offsetWidth;
            countdownNumber.style.animation = 'countdownPulse 1s ease-in-out';
        } else if (count === 0) {
            countdownNumber.textContent = 'GO!';
            countdownNumber.style.animation = 'none';
            void countdownNumber.offsetWidth;
            countdownNumber.style.animation = 'countdownPulse 1s ease-in-out';
        } else {
            clearInterval(timer);
            countdownOverlay.style.opacity = 0;
            startScrollingInternal();
        }
    }, 1000);
}

/* ---------- Scrolling ---------- */
function startScrollingInternal() {
  isScrolling = true;
  pauseBtn.textContent = '‚è∏ Pause';
  scrollInterval = setInterval(() => {
    // FIX: Allow scrolling until AFTER the final line (lines.length - 1) has been displayed
    if (currentLine < lines.length) { 
      currentLine++; updateDisplay();
    } else {
      stopScrolling(true);
    }
  }, currentSpeed);
}

function stopScrolling(completed = false) {
  isScrolling = false;
  pauseBtn.textContent = '‚ñ∂ Resume';
  if (scrollInterval) { clearInterval(scrollInterval); scrollInterval = null; }
  if (completed) {
    if (isRecording) stopRecording();
    showCompletionOverlay();
  }
}

function restartScrolling() {
  if (!isScrolling) return;
  stopScrolling(false);
  startScrollingInternal();
}

function updateDisplay() {
    // We update the classes only for segments that exist (lines.length - 1 and below)
    document.querySelectorAll('.line').forEach((el, idx) => {
        el.classList.remove('current', 'past', 'future');
        if (idx === currentLine) el.classList.add('current');
        else if (idx < currentLine) el.classList.add('past');
        else el.classList.add('future');
    });
    
    // This will now only scroll if currentLine is a valid index, due to the fix in scrollToCenter
    scrollToCenter(); 
    
    // Only update the position indicator if we are on a valid line
    if (currentLine < lines.length) {
        updatePosition();
    }
}

function updatePosition() {
  positionIndicator.textContent = `Segment ${currentLine + 1} of ${lines.length}`;
}

/* ---------- Navigation ---------- */
pauseBtn.addEventListener('click', () => { isScrolling ? stopScrolling(false) : startCountdown(); });
prevBtn.addEventListener('click', () => { if (currentLine > 0) { currentLine--; updateDisplay(); } });
nextBtn.addEventListener('click', () => { if (currentLine < lines.length - 1) { currentLine++; updateDisplay(); } });

/* ---------- Recording ---------- */
recordBtn.addEventListener('click', () => {
  if (!cameraEnabled || !stream) { 
    // REPLACED ALERT WITH NOTIFICATION
    showNotification('Please enable the camera and allow access to start recording.', true);
    return; 
  }
  if (!isRecording) {
    startRecording();
    if (!isScrolling) startCountdown();
  } else {
    stopRecording();
  }
});

function startRecording() {
  try {
    let options = {};
    if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) options = { mimeType: 'video/webm;codecs=vp9' };
    else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) options = { mimeType: 'video/webm;codecs=vp8' };
    else if (MediaRecorder.isTypeSupported('video/webm')) options = { mimeType: 'video/webm' };

    mediaRecorder = new MediaRecorder(stream, options);
    recordedChunks = [];

    mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) recordedChunks.push(e.data); };
    mediaRecorder.onstop = () => {
      downloadBtn.style.display = 'flex';
      if (completeOverlay.style.display === 'flex') overlayDownloadBtn.style.display = 'flex';
    };

    mediaRecorder.start(100);
    isRecording = true;

    recordBtn.classList.add('recording');
    recordBtn.textContent = '‚èπ Stop (0:00)';

    recordingTime = 0;
    recordingTimer = setInterval(() => {
      recordingTime++;
      const mins = Math.floor(recordingTime / 60);
      const secs = recordingTime % 60;
      recordBtn.textContent = `‚èπ Stop (${mins}:${secs.toString().padStart(2,'0')})`;
    }, 1000);

  } catch (error) {
    // REPLACED ALERT WITH NOTIFICATION
    showNotification('Could not start recording. Your browser may not support the necessary video formats. Error: ' + error.message, true);
  }
}

function stopRecording() {
  if (mediaRecorder && isRecording) {
    mediaRecorder.stop();
    isRecording = false;
    recordBtn.classList.remove('recording');
    recordBtn.textContent = '‚è∫ Record';
    if (recordingTimer) { clearInterval(recordingTimer); recordingTimer = null; }
  }
}

downloadBtn.addEventListener('click', () => {
  if (recordedChunks.length === 0) return;
  const blob = new Blob(recordedChunks, { type: 'video/webm' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `teleprompter-recording-${Date.now()}.webm`;
  a.click();
  URL.revokeObjectURL(url);
});

/* ---------- Reset ---------- */
resetBtn.addEventListener('click', () => {
  stopScrolling(false);
  if (isRecording) stopRecording();
  stopMediaStream();

  currentLine = 0;
  recordedChunks = [];
  downloadBtn.style.display = 'none';
  hideCompletionOverlay();

  isMirrored = false; isFlipped = false;
  mirrorBtn.classList.remove('active');
  flipBtn.classList.remove('active');
  applyVideoTransform();

  cameraEnabled = false;
  selectedCameraId = null;
  selectedMicId = null;
  cameraModeSelect.value = 'off';
  inputSelectContainer.style.display = 'none';
  setBadge(false);
  
  if (fontSizeRange) fontSizeRange.value = 3.5; 
  updateFontSize();

  document.body.classList.remove('reading-mode');
  setupScreen.style.display = 'block';
  readingScreen.style.display = 'none';
  document.body.classList.remove('reading-mode');
  updateCameraUI();
});

// Init
startBtn.disabled = true;
setBadge(false);
updateCameraUI();
if (fontSizeRange) updateFontSize();
</script>
</body>
</html>
